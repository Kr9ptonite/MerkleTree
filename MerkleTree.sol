// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Demo {
 
    // создаем условное наименование транзакций
    string[] public transactions = [
      "TX1: John -> Sue",
      "TX2: Sue -> John",
      "TX3: Dima -> Kostya",
      "TX4: April -> Roma"  
    ]; 
    
    bytes32[] public hashes; // байтовый массив, в котором будут храниться хэши

    // Получается, начало цикла начинается с i = 0, transactions.length = 4. Цикл будет выполняться 4 раза. Для каждой транзакции будет создаваться хэш от 0 до 3.
    // i служит для создания хэша по индексу массива transactions. Получается, i — это будет число, которое указывает на индекс массива, а в массиве уже содержится текст транзакции,
    // который попадет в input функции makeHash и, соответственно, захешируется.
    constructor() {
        for(uint i = 0; i < transactions.length; i++) {
            hashes.push(makeHash(transactions[i]));
        }

        // Мы добавили первые листья в массив hashes. При переходе на второй уровень дерева нам нужно объединить листья, которые у нас получились (по 2)
        uint count = transactions.length; // создаем переменную, которая будет хранить длину массива transactions
        uint offset = 0; // так как нам необходимо объединять хэши на втором уровне дерева, то нам понадобится переменная для смещения (обращения к хэшам по индексу)

        while(count > 0) {
            // i += 2, так как мы будем брать сразу по два хэша для второго уровня
            for(uint i = 0; i < count - 1; i += 2) {
                hashes.push(
                    keccak256(
                        abi.encodePacked(
                            hashes[offset + i], 
                            hashes[offset + i + 1] // +1 — это, соответственно, взять соседний элемент
                            // пока i < count - 1, используем функцию makeHash с аргументом, который будет хэшироваться из двух соседних хэшей для транзакций
                        )
                    )
                );
                offset += count; // обновляем offset для продолжения смещения по индексу. То есть это дает циклу понять, что мы закончили с предыдущими листьями.
                count = count / 2; // count делится на 2, так как количество хэшей уменьшается на каждом уровне из-за слияния
            }
        }
    }

    // Для тех, кто не понял, как работает весь цикл, объясняю поэтапно:
    // 1 итерация: count действительно больше нуля. i равно 0, начинаем выполнение нашего цикла. Выполняем abi-декодирование хэшей в массиве hashes, в который
    // мы уже занесли 4 листа. offset (переменная для смещения) равен нулю и i равен 0 — все правильно, мы обращаемся к массиву по индексу 0, в котором содержится хэш первой транзакции.
    // Потом мы обращаемся к соседу с помощью +1. Запятая в abi.encodePacked — это объединение переменных. Соответственно, мы получаем слияние, как подобает принципу Merkle Tree.
    // После выполнения тела цикла for мы прибавляем 2 к i для соответствующего смещения.

    // 2 итерация: все практически так же. Только мы обращаемся к индексу hashes уже как +2 и объединяем хэши H3 и H4. 
    // 3 итерация для цикла for с обновлением: после чего i уже становится больше, чем count, мы выходим из цикла for и возвращаемся к циклу while, где мы прибавляем к offset count (ниже написано), делим count на 2, так как мы уже будем объединять хэши H1-2 и H3-H4.
    // Следуя условию выполнения цикла while (count > 0), мы начинаем цикл for заново. 
    // Теперь, так как offset равен 4, мы объединяем наши листья H1-2 и H3-H4 по индексам хэшей 4 и 5 в массиве и получаем Root. Если бы было больше этажей, как обычно бывает — цикл бы пошел дальше.
    // Цикл, соответственно, остановился в for после того, как 2 < 2 (i < count) стало ложным, и в цикле while 0 > 0 (count > 0) — ложное.

    // Вот дерево, разбитое по индексам, с хэшами из массива hashes
    //                                 // ROOT[6]
    //                     // H1-2[4]             // H3-4[5]
   
    //                  //H1[0]    //H2[1]   // H3[2]    //H4[3]
   
    //                 // TX1        TX2       TX3        TX4

    // Создадим функцию для проверки транзакций по хэшу
    // Чтобы нам проверить подлинность транзакции в дереве, например, H3, нам нужно пересчитать корневой хэш. А чтобы вычислить корневой хэш, нам понадобятся H4 и H3, которые мы уже имеем, чтобы посчитать H3-H4, и хэш H1-2, чтобы, соответственно, посчитать root.
    // Итак, для проверки нам нужны хэши под индексами 3 и 2, пересчитать их в хэш под индексом 5 и хэш под индексом 4 — все это мы сможем пересчитать в root.
    // Для этих хэшей мы создаем массив proof.
    // bytes32 root — это как бы второй root для проверки с настоящим.

    function verify(string memory transaction, uint index, bytes32 root, bytes32[] memory proof) public returns(bool) {
        bytes32 hash = makeHash(transaction); // пересчитываем хэш проверяемой транзакции
        // создаем цикл, который будет пересчитывать хэши
        for(uint i = 0; i < proof.length; i++) {
            bytes32 element = proof[i]; // элемент из массива proof по индексу. Теперь нам нужно проверить четность индекса. Если индекс четный, то, чтобы нам посчитать общий хэш из двух листьев, нужно взять хэш справа, как показано на дереве. Если нечетный — слева.
            // bytes32 proof — это массив хэшей, чтобы доказать определенный хэш, и мы говорим, то есть в нем мы указываем всех необходимых соседей. Создается переменная element, и ей присваивается значение i-го элемента массива proof.
            // То есть в рамках массива proof H1-2 будет иметь индекс 1, а H4 — индекс 0.

            if(index % 2 == 0) {
                hash = keccak256(abi.encodePacked(hash, element));
            } else {
                hash = keccak256(abi.encodePacked(element, hash));
            }
            index = index / 2;
            return hash == root; // то есть мы получили два хэша. Цикл заново посчитал root, проверяя хэш выбранной транзакции, и сравниваем с действительным root
        }
    }

    // Поэтапная работа цикла: i = 0, начинаем цикл. Берется element, который становится значением в массиве proof под индексом 0.
    // Теперь мы указываем индекс хэша транзакции, которую хотим проверить. Индекс нужен для указания либо влево, либо вправо, как я описывал выше.
    // Элемент четный. Пересчитывается хэш соседних элементов. Мы берем hash проверяемой транзакции и хэш соседнего элемента с индексом 0 в массиве proof.
    // index делится на 2, и мы получаем индекс 1 (H1-2). В следующей итерации мы получаем, что индекс кратен 2. Значит, мы берем сначала element (H1-2) и hash — значение, которое мы посчитали на предыдущей итерации.
    // И результатом всего становится hash, который будет являться root-ом.

    // создаем две функции, которые будут выполнять хэш из байтов заданного аргумента
    function encode(string memory input) public pure returns(bytes memory) {
        return abi.encode(input);
    }

    function makeHash(string memory input) public pure returns(bytes32) {
        return keccak256(encode(input));
    }
}
